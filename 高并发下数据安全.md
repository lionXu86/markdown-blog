## 并发下的数据安全问题

> 将库存字段number字段设为unsigned，当库存为0时，因为字段不能为负数，将会返回false

在单机单进程单线程或者单协程的情况下，数据的操作者只有一个，公共数据的读写是串行的，不存在判断数据不一致导致数据出问题。但是在多进程或者多连接即并发的情况下，数据的 读 会带来很多问题，读的结果是否是最终一致性影响着最后 写 的正确性，所以并发下数据安全问题其实最终解决的是 读 的问题。

解决读的正确性一般有2种解决办法，一个是锁（重复试错），一个是队列（串行化）。


### 锁

锁有很多种，java里就有很多不同场景下使用的不同类型的锁，但是是仅限单机的情况下。实现这些锁，数据库本身可以实现很强的串行化操作，常用的就是悲观锁和乐观锁。

#### 悲观锁

悲观的认为数据在更新之前都已经被修改过了，所以不管怎样都加锁。使用这种锁用的很多，包括读锁，写锁，行锁等七七八八的锁，都在悲观锁的范畴之内，简单来说就是加了阻塞，只有获得锁才有更新权限，不然就阻塞等待。一旦加了悲观锁，每个请求都得等待上个请求释放锁，竞争锁，导致请求都阻塞等待，连接超时异常。

但是悲观锁不能完全解决数据读不一致的问题，最好的可重复度方案在高并发下还是会存在幻读（可能有不同定义，这里不是同一个sess会话里面更新之前读的数据是否一致，而是否锁住读，读阻塞，从而保证不同session里读的一致性，这个本身不是数据库的问题，而是数据库的隔离级别解决的问题并不能业务逻辑需求产生的问题）的问题，所以最终还是需要通过乐观锁解决。


#### 乐观锁
就是不加锁，乐观的认为数据更新之前没有发生变化，所以才操作数据之钱不加锁，在进行更新的时候再去判断是否有被更新过。乐观锁需要我们自己去实现，数据库没有实现这种锁。通常的做法是加version版本号或者时间戳，更新之钱判断该字段是否和更新前的值一致。是则更新，反正放弃。

虽然能解决问题，但是在高高高高并发的情况下也有不足，缺点是带来大量是试错请求处理，给数据库带来很大的压力，算是一种可优化的折中方案。

优化方案之一，通过redis实现的cas机制实现

redis通过cas方式如下
```
WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
```

### 队列

串行化实现方案，虽然能解决问题，但是在高高高高并发的情况下也有不足，需要针对实际情况优化。


